
import { createBLAKE3 } from "hash-wasm";

// #region Utilities
function utf8ToBytes(str) {
    return new TextEncoder().encode(str);
}

function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2 !== 0) {
        throw new Error('hexToBytes: received invalid unpadded hex');
    }
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) {
            throw new Error('Invalid byte sequence');
        }
        array[i] = byte;
    }
    return array;
}

function concatBytes(...arrays) {
    const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
// #endregion

export const HARDENED_OFFSET = 0x80000000; // 2^31
const ZERO = new Uint8Array([0]);

// A deterministic, 32-byte secret key generated by hashing a constant string.
// This is used as the key for the initial master seed derivation.
let masterSecretKey = null;
async function getMasterSecretKey() {
    if (!masterSecretKey) {
        const hasher = await createBLAKE3(); // Default 256-bit (32-byte) output
        hasher.update(utf8ToBytes('lea-chain-hd-key-master-secret'));
        masterSecretKey = hasher.digest('binary');
    }
    return masterSecretKey;
}


/**
 * Helper function to ensure input is Uint8Array and validate length.
 * @param {Uint8Array | string} input - The input value (Uint8Array or hex string).
 * @param {...number} expectedLengths - Optional expected lengths for validation.
 * @returns {Uint8Array} The validated input as a Uint8Array.
 */
function ensureBytes(input, ...expectedLengths) {
    let bytes;
    if (typeof input === 'string') {
        try { bytes = hexToBytes(input); } catch (e) { throw new TypeError(`Invalid hex string: ${e instanceof Error ? e.message : e}`); }
    } else if (input instanceof Uint8Array) {
        bytes = input;
    } else { throw new TypeError(`Input must be a Uint8Array or a hex string, got ${typeof input}`); }
    if (expectedLengths.length > 0 && !expectedLengths.includes(bytes.length)) { throw new Error(`Invalid input length: ${bytes.length}. Expected one of: ${expectedLengths.join(', ')}`); }
    return bytes;
}

/** Write number to Uint32BE Uint8Array. */
const numberToBytesBE = (num) => {
    if (!Number.isSafeInteger(num) || num < 0 || num >= 2 ** 32) { throw new Error(`Invalid number: ${num}. Must be >= 0 and < 2^32`); }
    const buffer = new Uint8Array(4);
    new DataView(buffer.buffer).setUint32(0, num, false); // Big Endian
    return buffer;
};

/**
 * Represents a Hierarchical Deterministic Key generator based on SLIP-0010 using BLAKE3.
 * This class is used to derive a tree of secret keys.
 */
export class HDKey {
    /** @type {Uint8Array} The 32-byte key */
    key;
    /** @type {Uint8Array} The 32-byte chain code */
    chainCode;

    /**
     * Private constructor. Use HDKey.fromMasterSeed() to create instances.
     * @param {object} options Internal options.
     * @private
     */
    constructor(options) {
        if (!(options.key instanceof Uint8Array) || options.key.length !== 32) { throw new TypeError("key must be a 32-byte Uint8Array"); }
        if (!(options.chainCode instanceof Uint8Array) || options.chainCode.length !== 32) { throw new TypeError("chainCode must be a 32-byte Uint8Array"); }
        this.key = options.key;
        this.chainCode = options.chainCode;
    }

    /**
     * Creates an HDKey from a master seed.
     * @param {Uint8Array | string} seed - The master seed (bytes or hex string). Recommended: 32 bytes. Min: 16 bytes, Max: 64 bytes.
     * @returns {Promise<HDKey>} A new HDKey instance representing the master node (m).
     */
    static async fromMasterSeed(seed) {
        const seedBytes = ensureBytes(seed);
        const seedLengthBits = seedBytes.length * 8;
        if (seedLengthBits < 128 || seedLengthBits > 512) { throw new Error(`Invalid seed length: ${seedBytes.length} bytes (${seedLengthBits} bits). Must be between 128 and 512 bits.`); }
        
        const masterKey = await getMasterSecretKey();
        const hasher = await createBLAKE3(512, masterKey); // 512-bit (64-byte) output
        hasher.update(seedBytes);
        const I = hasher.digest('binary');

        const key = I.slice(0, 32);
        const chainCode = I.slice(32, 64);
        return new this({ key: key, chainCode: chainCode });
    }

    /**
     * Derives a child key based on a BIP32 path string (e.g., "m/44'/501'/0'") and returns its key.
     * NOTE: Only hardened derivation (using ") is supported.
     * @param {string} path - The derivation path string. Must start with 'm'.
     * @returns {Promise<Uint8Array>} The derived 32-byte key (seed).
     */
    async derive(path) {
        if (!/^[mM](?:\/[0-9]+'?)*$/.test(path)) {
            throw new Error("Invalid derivation path format. Expected \"m/...\" with hardened indices (e.g., \"m/44'/0'\")");
        }
        if (path === 'm' || path === 'M') { return this.key; }
        const segments = path.replace(/^[mM]\/?/, '').split('/');
        let currentKey = this;
        for (const segment of segments) {
            const match = /^([0-9]+)('?)$/.exec(segment);
            if (!match) { throw new Error(`Invalid path segment: ${segment}`); }
            let index = parseInt(match[1], 10);
            const isHardened = match[2] === "'";
            if (!Number.isSafeInteger(index) || index >= HARDENED_OFFSET) { throw new Error(`Invalid index number: ${index}. Must be < 2^31.`); }
            if (!isHardened) { throw new Error(`Non-hardened derivation (index ${index}) is not supported. Use hardened index (e.g., ${index}'').`); }
            index += HARDENED_OFFSET;
            currentKey = await currentKey.deriveChild(index);
        }
        return currentKey.key;
    }

    /**
     * Derives a child key using a specific index.
     * NOTE: Only hardened indices (index >= HARDENED_OFFSET) are supported.
     * @param {number} index - The child index number. Must be >= HARDENED_OFFSET.
     * @returns {Promise<HDKey>} The derived HDKey instance.
     */
    async deriveChild(index) {
        if (!Number.isSafeInteger(index) || index < HARDENED_OFFSET || index >= 2 ** 32) { throw new Error(`Invalid index ${index}. Hardened index must be >= ${HARDENED_OFFSET} and < 2^32.`); }
        const indexBytes = numberToBytesBE(index);
        const data = concatBytes(ZERO, this.key, indexBytes);

        const hasher = await createBLAKE3(512, this.chainCode); // 512-bit (64-byte) output
        hasher.update(data);
        const I = hasher.digest('binary');

        const childKey = I.slice(0, 32);
        const childChainCode = I.slice(32, 64);
        return new this.constructor({
            key: childKey,
            chainCode: childChainCode,
        });
    }
}
