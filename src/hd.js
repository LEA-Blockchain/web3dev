/*
Attribution & Copyright Comments:
Original work Copyright (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com)
This code is based on the original work by Patricio Palladino and Paul Miller.
Modifications Copyright (c) 2025, Allwin Ketnawang (getlea.org)

The MIT License (MIT)

Copyright (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com)
Copyright (c) 2025, Allwin Ketnawang (getlea.org)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

import { createBLAKE3 } from "hash-wasm";
import {
    concatBytes, createView, hexToBytes,
    utf8ToBytes
} from "@noble/hashes/utils";

export const HARDENED_OFFSET = 0x80000000; // 2^31
const ZERO = new Uint8Array([0]);

// A deterministic, 32-byte secret key generated by hashing a constant string.
// This is used as the key for the initial master seed derivation.
let masterSecretKey = null;
async function getMasterSecretKey() {
    if (!masterSecretKey) {
        const hasher = await createBLAKE3(); // Default 256-bit (32-byte) output
        hasher.update(utf8ToBytes('lea-chain-hd-key-master-secret'));
        masterSecretKey = hasher.digest('binary');
    }
    return masterSecretKey;
}


/**
 * Helper function to ensure input is Uint8Array and validate length.
 * @param {Uint8Array | string} input - The input value (Uint8Array or hex string).
 * @param {...number} expectedLengths - Optional expected lengths for validation.
 * @returns {Uint8Array} The validated input as a Uint8Array.
 */
function ensureBytes(input, ...expectedLengths) {
    let bytes;
    if (typeof input === 'string') {
        try { bytes = hexToBytes(input); } catch (e) { throw new TypeError(`Invalid hex string: ${e instanceof Error ? e.message : e}`); }
    } else if (input instanceof Uint8Array) {
        bytes = input;
    } else { throw new TypeError(`Input must be a Uint8Array or a hex string, got ${typeof input}`); }
    if (expectedLengths.length > 0 && !expectedLengths.includes(bytes.length)) { throw new Error(`Invalid input length: ${bytes.length}. Expected one of: ${expectedLengths.join(', ')}`); }
    return bytes;
}

/** Write number to Uint32BE Uint8Array. */
const numberToBytesBE = (num) => {
    if (!Number.isSafeInteger(num) || num < 0 || num >= 2 ** 32) { throw new Error(`Invalid number: ${num}. Must be >= 0 and < 2^32`); }
    const buffer = new Uint8Array(4);
    createView(buffer).setUint32(0, num, false); // Big Endian
    return buffer;
};

/**
 * Represents a Hierarchical Deterministic Key generator based on SLIP-0010 using BLAKE3.
 * This class is used to derive a tree of secret keys.
 */
export class HDKey {
    /** @type {Uint8Array} The 32-byte key */
    key;
    /** @type {Uint8Array} The 32-byte chain code */
    chainCode;

    /**
     * Private constructor. Use HDKey.fromMasterSeed() to create instances.
     * @param {object} options Internal options.
     * @private
     */
    constructor(options) {
        if (!(options.key instanceof Uint8Array) || options.key.length !== 32) { throw new TypeError("key must be a 32-byte Uint8Array"); }
        if (!(options.chainCode instanceof Uint8Array) || options.chainCode.length !== 32) { throw new TypeError("chainCode must be a 32-byte Uint8Array"); }
        this.key = options.key;
        this.chainCode = options.chainCode;
    }

    /**
     * Creates an HDKey from a master seed.
     * @param {Uint8Array | string} seed - The master seed (bytes or hex string). Recommended: 32 bytes. Min: 16 bytes, Max: 64 bytes.
     * @returns {Promise<HDKey>} A new HDKey instance representing the master node (m).
     */
    static async fromMasterSeed(seed) {
        const seedBytes = ensureBytes(seed);
        const seedLengthBits = seedBytes.length * 8;
        if (seedLengthBits < 128 || seedLengthBits > 512) { throw new Error(`Invalid seed length: ${seedBytes.length} bytes (${seedLengthBits} bits). Must be between 128 and 512 bits.`); }
        
        const masterKey = await getMasterSecretKey();
        const hasher = await createBLAKE3(512, masterKey); // 512-bit (64-byte) output
        hasher.update(seedBytes);
        const I = hasher.digest('binary');

        const key = I.slice(0, 32);
        const chainCode = I.slice(32, 64);
        return new this({ key: key, chainCode: chainCode });
    }

    /**
     * Derives a child key based on a BIP32 path string (e.g., "m/44'/501'/0'") and returns its key.
     * NOTE: Only hardened derivation (using ") is supported.
     * @param {string} path - The derivation path string. Must start with 'm'.
     * @returns {Promise<Uint8Array>} The derived 32-byte key (seed).
     */
    async derive(path) {
        if (!/^[mM](?: H)?(\/[0-9]+'?)*$/.test(path)) {
            throw new Error('Invalid derivation path format. Expected "m/..." with hardened indices (e.g., "m/44\'/0\'").');
        }
        if (path === 'm' || path === 'M') { return this.key; }
        const segments = path.replace(/^[mM]\/?/, '').split('/');
        let currentKey = this;
        for (const segment of segments) {
            const match = /^([0-9]+)('?)$/.exec(segment);
            if (!match) { throw new Error(`Invalid path segment: ${segment}`); }
            let index = parseInt(match[1], 10);
            const isHardened = match[2] === "'";
            if (!Number.isSafeInteger(index) || index >= HARDENED_OFFSET) { throw new Error(`Invalid index number: ${index}. Must be < 2^31.`); }
            if (!isHardened) { throw new Error(`Non-hardened derivation (index ${index}) is not supported. Use hardened index (e.g., ${index}'').`); }
            index += HARDENED_OFFSET;
            currentKey = await currentKey.deriveChild(index);
        }
        return currentKey.key;
    }

    /**
     * Derives a child key using a specific index.
     * NOTE: Only hardened indices (index >= HARDENED_OFFSET) are supported.
     * @param {number} index - The child index number. Must be >= HARDENED_OFFSET.
     * @returns {Promise<HDKey>} The derived HDKey instance.
     */
    async deriveChild(index) {
        if (!Number.isSafeInteger(index) || index < HARDENED_OFFSET || index >= 2 ** 32) { throw new Error(`Invalid index ${index}. Hardened index must be >= ${HARDENED_OFFSET} and < 2^32.`); }
        const indexBytes = numberToBytesBE(index);
        const data = concatBytes(ZERO, this.key, indexBytes);

        const hasher = await createBLAKE3(512, this.chainCode); // 512-bit (64-byte) output
        hasher.update(data);
        const I = hasher.digest('binary');

        const childKey = I.slice(0, 32);
        const childChainCode = I.slice(32, 64);
        return new this.constructor({
            key: childKey,
            chainCode: childChainCode,
        });
    }
}
