import {
    generateMnemonic as customGenerateMnemonic,
    mnemonicToSeed as customMnemonicToSeed
} from '../../src/bip39.js';

import * as scureBip39 from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
import { randomBytes, bytesToHex } from '@noble/hashes/utils';

// --- Custom Byte Array Comparison ---
function customEqualBytes(a, b) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        console.error("customEqualBytes received non-Uint8Array input");
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}

// --- Test Configuration ---
const STRENGTHS_BITS = [128, 160, 192, 224, 256];
const ITERATIONS_PER_STRENGTH = 100;

// --- Test Suite ---
console.log("--- Custom BIP39 vs @scure/bip39 Comparison Test ---");
console.log(`--- Testing ${ITERATIONS_PER_STRENGTH} iterations per strength ---`);

async function runComparisonTests() {
    let overallPassed = true;
    let totalFailures = 0;

    // --- Static Invalid Mnemonic Tests (Expect Throws) ---
    console.log("\n[Test Case: Static Invalid Mnemonics (Expect Throws)]");
    let staticTestsPassed = true;

    const invalidChecksumMnemonic = "witch collapse practice feed shame open despair creek road again ice zoo"; // checksum wrong
    try {
        customMnemonicToSeed(invalidChecksumMnemonic); // Should throw
        console.error(`  ERROR: customMnemonicToSeed DID NOT THROW for invalid checksum: "${invalidChecksumMnemonic.substring(0, 20)}..."`);
        staticTestsPassed = false;
        totalFailures++;
    } catch (error) {
        // Expected path
        if (error.message?.includes('Checksum mismatch')) {
            console.log(`  Validation (Invalid Checksum): Correctly threw error: ${error.message}`);
        } else {
            console.warn(`  Validation (Invalid Checksum): Threw an unexpected error: ${error.message}`);
        }
    }

    const invalidWordMnemonic = "witch collapse practice feed shame open despair creek road again ice unknownword";
    try {
        customMnemonicToSeed(invalidWordMnemonic); // Should throw
        console.error(`  ERROR: customMnemonicToSeed DID NOT THROW for unknown word: "${invalidWordMnemonic.substring(0, 20)}..."`);
        staticTestsPassed = false;
        totalFailures++;
    } catch (error) {
        // Expected path
        if (error.message?.includes('not found in wordlist')) {
            console.log(`  Validation (Unknown Word): Correctly threw error: ${error.message}`);
        } else {
            console.warn(`  Validation (Unknown Word): Threw an unexpected error: ${error.message}`);
        }
    }

    const invalidCountMnemonic = "witch collapse practice feed shame open despair creek road again ice"; // Too short
    try {
        customMnemonicToSeed(invalidCountMnemonic); // Should throw
        console.error(`  ERROR: customMnemonicToSeed DID NOT THROW for invalid word count: "${invalidCountMnemonic.substring(0, 20)}..."`);
        staticTestsPassed = false;
        totalFailures++;
    } catch (error) {
        // Expected path
        if (error.message?.includes('Invalid mnemonic word count')) {
            console.log(`  Validation (Invalid Word Count): Correctly threw error: ${error.message}`);
        } else {
            console.warn(`  Validation (Invalid Word Count): Threw an unexpected error: ${error.message}`);
        }
    }

    console.log(`[Static Invalid Tests Result: ${staticTestsPassed ? "PASSED" : "FAILED"}]`);
    if (!staticTestsPassed) {
        overallPassed = false;
    }

    // --- Loop through strengths ---
    for (const strength of STRENGTHS_BITS) {
        const entropyBytes = strength / 8;
        console.log(`\n--- Testing Strength: ${strength} bits (${entropyBytes} bytes entropy) ---`);
        let failuresThisStrength = 0;

        for (let i = 0; i < ITERATIONS_PER_STRENGTH; i++) {
            let currentRunPassed = true;
            let customMnemonic = '';

            try {
                customMnemonic = customGenerateMnemonic(strength);

                // 2. Test Validation (Using @scure/bip39 on custom-generated mnemonic)
                // Ensure the mnemonic generated by our library is considered valid by the standard library.
                const scureIsValid = scureBip39.validateMnemonic(customMnemonic, wordlist);
                if (!scureIsValid) {
                    console.error(`  ERROR (Strength ${strength}, Run ${i + 1}): @scure/bip39 failed to validate custom-generated mnemonic!`);
                    console.error(`    Mnemonic: ${customMnemonic}`);
                    currentRunPassed = false;
                }

                // 3. Test Mnemonic -> Entropy Recovery (using @scure/bip39)
                // Check that scure can process the custom mnemonic to entropy.
                try {
                    scureBip39.mnemonicToEntropy(customMnemonic, wordlist);
                } catch (entropyError) {
                    console.error(`  ERROR (Strength ${strength}, Run ${i + 1}): @scure/bip39 failed mnemonicToEntropy for custom-generated mnemonic!`);
                    console.error(`    Mnemonic: ${customMnemonic}`);
                    console.error(`    Error: ${entropyError.message}`);
                    currentRunPassed = false;
                }

                // 4. Test Mnemonic -> Seed (using the mnemonic generated by custom lib)
                // This now implicitly tests customMnemonicToSeed's validation too.

                // 4a. No passphrase comparison
                const scureSeed1 = scureBip39.mnemonicToSeedSync(customMnemonic);
                const customSeed1 = customMnemonicToSeed(customMnemonic);
                if (!customEqualBytes(scureSeed1, customSeed1)) {
                    console.error(`  ERROR (Strength ${strength}, Run ${i + 1}): mnemonicToSeed (no pass) mismatch!`);
                    console.error(`    Mnemonic: ${customMnemonic}`);
                    currentRunPassed = false;
                }

                // 4b. With **RANDOM** passphrase comparison
                const randomPassphraseBytes = randomBytes(16);
                const randomPassphrase = bytesToHex(randomPassphraseBytes);

                const scureSeed2 = scureBip39.mnemonicToSeedSync(customMnemonic, randomPassphrase);
                const customSeed2 = customMnemonicToSeed(customMnemonic, randomPassphrase);
                if (!customEqualBytes(scureSeed2, customSeed2)) {
                    console.error(`  ERROR (Strength ${strength}, Run ${i + 1}): mnemonicToSeed (with random pass) mismatch!`);
                    console.error(`    Mnemonic: ${customMnemonic}`);
                    console.error(`    Passphrase (hex): ${randomPassphrase}`); // Log passphrase on error
                    currentRunPassed = false;
                }

            } catch (e) {
                console.error(`  ERROR (Strength ${strength}, Run ${i + 1}): Test threw an unexpected exception: ${e}`);
                if (e?.stack) console.error(e.stack); // Log stack trace if available
                if (customMnemonic) console.error(`    Mnemonic being tested: ${customMnemonic}`); // Log mnemonic on error
                currentRunPassed = false;
            }

            if (!currentRunPassed) {
                failuresThisStrength++;
                overallPassed = false;
            }
        }

        if (failuresThisStrength === 0) {
            console.log(`--- Strength ${strength} bits: ${ITERATIONS_PER_STRENGTH} tests PASSED ---`);
        } else {
            totalFailures += failuresThisStrength;
            console.error(`--- Strength ${strength} bits: ${failuresThisStrength} / ${ITERATIONS_PER_STRENGTH} tests FAILED ---`);
        }
    }

    // --- Log Overall Result ---
    console.log(`\n--- Overall Comparison Result: ${overallPassed ? "ALL PASSED" : "SOME FAILED"} ---`);
    if (!overallPassed) {
        console.error(`Comparison failed! Total failures: ${totalFailures}. Check the errors above.`);
        // process.exit(1); // Optional: exit with error code if tests fail
    } else {
        console.log("Congratulations! Your custom implementation's exported functions appear consistent with @scure/bip39 across all tested strengths and passphrases, and validation checks behave as expected.");
    }
}

runComparisonTests().catch(err => {
    console.error("Unhandled error during test execution:", err);
    // process.exit(1); // Optional: exit with error code if tests fail
});